(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/**
 *  COUNTY DASHBOARD
 *
 *  This app creates a dashboard that allows the user to toggle between
 *  Washington state, region and county maps and get population/trend data
 *  for each view. It was originally created in 2013.
 */

// Require all modules so that they can be initialized
var Events = require('./modules/Events.js');
var DataService = require('./modules/Dataservice.js');

// UI Modules
var ContextSwitcher = require('./modules/ContextSwitcher.js');
var FastFacts = require('./modules/FastFacts.js');
var Map = require('./modules/Map.js');
var Sparklines = require('./modules/Sparklines.js');

// Initialize the dashboard
var Dashboard = (function() {
	// Configuration options used throughout the app. These are
	// the only options that should need occasional attention or
	// updating. Eventually the date range should be determined
	// automatically.
	var defaultContext = 'state';
	var path = 'data/new-data/';
	var files = ['_context', '_data']; // files to be loaded per context
	var dateRange = [ 2000, 2015];
	var contexts = ['state', 'county', 'region'];
	var colors = {
		main: "#3B6E8F",
		highlight: "#A3DCE6",
		accent: "green"
	};

	// Initialize the application modules with whatever
	// settings they need to run
	function init() {
		DataService.init(defaultContext, path, files);
		ContextSwitcher.init(contexts, colors);
		FastFacts.init(defaultContext, files);
		Map.init(defaultContext, colors);
		Sparklines.init(defaultContext, files, dateRange, colors);
	}

	return {
		run: init
	}
})();

Dashboard.run();
},{"./modules/ContextSwitcher.js":2,"./modules/Dataservice.js":3,"./modules/Events.js":4,"./modules/FastFacts.js":5,"./modules/Map.js":6,"./modules/Sparklines.js":7}],2:[function(require,module,exports){
/**
 *  CONTEXT SWITCHER
 *
 *  Constructs a list of buttons that allow the user to switch between
 *  the state, region and county contexts
 */

var Events = require('./Events.js');


var ContextSwitcher = (function() {

	function init(contexts, colors) {
		appendButtons(contexts, colors);
		bindEvents(colors);
	}

	function appendButtons(contexts, colors) {
		var buttons = d3.select("#context-buttons");

		// buttons (will appear left-to-right in reverse order from laid out here)
		buttons.selectAll('.s_r_c')
			.data(contexts)
			.enter()
			.append("div")
			.attr("class", "s_r_c")
			.attr("id", function(d){ return d; })
			.text(function(d){ return d; });

		// Set default state
		d3.select("#context-buttons")
		.selectAll("div")
		.attr("checked", "unchecked")
		.style("border-color", d3.hsl(colors['main']).brighter(1.2));
	}

	function bindEvents(colors) {
		// button hover behavior
		d3.select("#context-buttons")
		.selectAll("div")
		.on("mouseover", function () {
		    d3.select(this).style("border-color", d3.hsl(colors['highlight']).brighter(0.5));
		})
		.on("mouseout", function () {
		    if (d3.select(this).attr("checked") == "unchecked") {
		        d3.select(this).style("border-color", d3.hsl(colors['main']).brighter(1.2));
		    } else {
		        d3.select(this).style("border-color", colors['highlight']);

		    }
		})
		.on('click', function() {
			var newContext;
			// Uncheck and unhighlight whatever was previously selected
			d3.selectAll('div.s_r_c')
		    .attr('checked', 'unchecked')
		    .style("border-color", d3.hsl(colors['main']).brighter(1.2));

		   // Now check and highlight the current selection
		   d3.select(this)
		    .attr('checked', 'checked')
			 .style("border-color", colors['highlight']);

			// Get the ID of the current selection and publish it as a context
			// switch event
			var id = d3.select(this).attr('id');			
			Events.publish('Switch contexts', {
				context: id
			});
		});
	}

	return {
		init: init
	}
})();

module.exports = ContextSwitcher;
},{"./Events.js":4}],3:[function(require,module,exports){
/**
 *  DATA SERVICE
 *
 *  Ingests data and distributes it to the Events modules, which makes the data
 *  available to other modules. Responds to context changes by sending out new data for
 *  the current context.
 */

var Events = require('./Events.js');

var DataService = (function() {

    // Private variables accessible throughout the module
    // that get set on init
    var path;
    var files;

    function init(context, dataPath, filesList) {
        // Set module globals
        path = dataPath;
        files = filesList;

        // Load the data with the defaults
        setupDataLoad(context);

        // Listen for data context changes from the ContextSwitcher module
        Events.subscribe('Switch contexts', function(obj) {
            var newContext = obj.context;
            setupDataLoad(newContext)
        });
    }

    // Loop over files that need to be loaded and load them using
    // d3.csv, then publish the data when ready
    function setupDataLoad(context) {
        var dataset;
        var filename;
        var toLoad;
        var msg;

        // Set up load options
        for (var i = 0; i < files.length; i++) {
            filename = context + files[i];
            toLoad = window.location.href + path + filename + '.csv';
            msg = filename.split('_')[1] + ' loaded';

            // Initiate D3 CSV load
            loadData(msg, context, toLoad);
        }    
    }

    // Uses d3.csv method to asynchronously load the data and publishes
    // when ready
    function loadData(msg, context, toLoad) {
        var dataset;

        d3.csv(toLoad, function(data) {
            dataset = data;

            Events.publish(msg, {
                context: context,
                data: dataset
            });
        });
    }

    return {
        init: init
    };

})();

module.exports = DataService;
},{"./Events.js":4}],4:[function(require,module,exports){
/*
 * EVENTS
 *
 * Simple pub/sub class for notifying other modules of
 * data load events from http://davidwalsh.name/pubsub-javascript.
 *
 * This module provides communication about events without
 * creating dependencies between other modules.
 */

var Events = (function(){
  var topics = {};
  var hOP = topics.hasOwnProperty;

  return {
    subscribe: function(topic, listener) {
      // Create the topic's object if not yet created
      if(!hOP.call(topics, topic)) topics[topic] = [];

      // Add the listener to queue
      var index = topics[topic].push(listener) -1;

      // Provide handle back for removal of topic
      return {
        remove: function() {
          delete topics[topic][index];
        }
      };
    },
    publish: function(topic, info) {
      // If the topic doesn't exist, or there's no listeners in queue, just leave
      if(!hOP.call(topics, topic)) return;

      // Cycle through topics queue, fire!
      topics[topic].forEach(function(item) {
      		item(info != undefined ? info : {});
      });
    }
  };
})();

module.exports = Events;
},{}],5:[function(require,module,exports){
/**
 *  FAST FACTS
 *
 *  Appends fast facts to the bottom of the page with population-based
 *  demographic indicators.
 */

var Events = require('./Events.js');

var FastFacts = (function() {

	function init(defaultContext, files) {
		// Subscribe to the data load for each file we need to load
		for(var i = 0; i < files.length; i++) {
			var fileName = defaultContext + files[i];
			
			Events.subscribe(defaultContext + files[i], function(obj) {
				console.log('It happened: ' + defaultContext + files[i]);
			});
		}
	}

	function update() {

	}

	function switchContext() {

	}

	function extractData() {

	}

	function appendFactsContainer() {

	}

	function appendFact(context) {

	}

	function bindEvents() {

	}

	return {
		init: init
	}
})();

module.exports = FastFacts;
},{"./Events.js":4}],6:[function(require,module,exports){
/**
 *  MAP
 *
 *  Appends an SVG mp of Washington to the page and binds
 *  data to paath fills.
 */

var Events = require('./Events.js');

var Map = (function() {
   // base colors for the map, map scale, and radio button outlines - these get 
   // manipulated with d3 functions to produce the full gradient needed for
   // the map scale
   var color_main = "#3B6E8F";
   var color_highlight = "#A3DCE6";

   // Initialize event listeners
   function init(defaultContext, colors) {
      appendMap(defaultContext, colors);

      Events.subscribe('Switch contexts', function(obj) {
         var context = obj.context;
         console.log(context);
         document.getElementById('map-container').innerHTML = '';
         appendMap(context, colors);
      });
   }

   function switchContext() {

   }

   function appendMap(context, colors) {
     // mapID and mapHeight are used in the same way regardless of context
     var mapID = 'wa_' + context + '_map';
     var mapHeight = 500;

      // Settings for region or county SVG
     var settings = getContextSettings(context);

      // First check to make sure that the map does not already exist. Each map context
      // has a different ID; if it already exists, we don't need to append the map again.
        var svg = d3.select("#map-container").append("svg")
                .attr("id", mapID)
                .attr("class", "map")
                .attr("viewBox", settings.viewBox)
                .attr("width", settings.mapWidth)
                .attr("height", mapHeight);
        
        // Loops over the data in the regions array and attaches name, id, and class to a <g> element
        var map = svg.selectAll("g")
                          .data(settings.geography)
                          .enter().append("g") 
                          .attr("class", context)
                          .attr("id", function(d){ return d.id; });

        // Appends path and "d" attribute to each item from the data
        map.append("path")
                  .attr("d",function(d){ return d.path; })
                  .attr("id", function(d){ return d.geog; })
                  .attr("name", function(d){ return d.name; })
                  .attr("transform", settings.transform)
                  .attr("class", "wa_geo_map")
                  .style("stroke","#fff")
                  .style("stroke-width", settings.strokeWidth);

      // Loops over data array and checks it against the county/region_path array. If the ID matches the name of a county/region in county/region_path, an additional path is appended to the <g> element. This catches all of the islands that cannot be captured with a single path.
        for(var i=0, c_len=settings.geography.length;i<c_len;i++){
          for(var j=0, p_len=settings.extraPaths.length;j<p_len;j++){
              if(settings.geography[i]["id"]==settings.extraPaths[j][context]){
                  d3.select("#"+settings.geography[i]["id"]).append("path")
                      .attr("d",settings.extraPaths[j]["path"])
                       .attr("class", "wa_geo_map")
                      .style("stroke","#fff")
                      .style("stroke-width", settings.strokeWidth);  
              }
          }
        }
   }

   function updateFill() {

   }

   function bindEvents() {

   }

   function getContextSettings(context) {
       var svgSettings;

       switch(context) {
         case "state":
           svgSettings = {
             viewBox: "50 50 860 500",
             geography: regions,
             extraPaths: region_path,
             transform: "translate(0, -50)",
             strokeWidth: "0",
             mapWidth: 615
           };
           break;
         case "region":
           svgSettings = {
             viewBox: "50 50 860 500",
             geography: regions,
             extraPaths: region_path,
             transform: "translate(0, -50)",
             strokeWidth: "2",
             mapWidth: 615
           };
           break;
         case "county":
           svgSettings = {
             viewBox: "-32550,-19037 59361,38626",
             geography: counties,
             extraPaths: county_path,
             transform: "translate(0, 0)",
             strokeWidth: "100",
             mapWidth: 580
           };
           break;
       }

       return svgSettings;
   }

   return {
      init: init
   }
})();

module.exports = Map;
},{"./Events.js":4}],7:[function(require,module,exports){
/**
 *  SPARKLINES
 *
 *  Appends a series of sparklines to the page sidebar with indicators related
 *  to the child welfare system in the current context
 */

var Events = require('./Events.js');

var Sparklines = (function() {
   // Display options made available to all fucntions
   var margin_t = {
       top : 5,
       right : 5,
       bottom : 5,
       left : 35
   };
   var svg_w = 500;
   var svg_h = 90;
   var sparkline_w = 340;
   var sparkline_h = 90;
   var years;
   var dataLength;

   // Run on dashboard initialization
   function init(defaultContext, files, domain, colors) {
      // Set the years array for use by the appendSparklinesGrid
      // and appendSparklinesAxis functions
      years = getNumYears(domain);

      // Subscribe to context load event, which returns all
      // of the data for sparklines
      Events.subscribe('context loaded', function(result) {
         var data = getSparklineData(result.data);

         // The number of objects in the data array gives the multiplier for the
         // height of the SVG. Defined globally within the module because several
         // different functions initiated below need it.
         dataLength = Object.keys(data).length;

         // Start by removing the existing sparkline container. D3 works by appending
         // elements and does not seem to be great at simply updating state, so this
         // route is simpler if a bit clunk
         d3.select('#sparklines').remove();

         // Append the different components of the sparkline grid, from
         // general to specific. They need to be created in this order for
         // the elements to overlap properly.
         appendSparklines(data, domain);
         appendSparklineGrid();
         appendSparklineAxis(domain);
      });
   }

   function update() {

   }

   // Although the HTML markup provides a lot of structure, D3 binds data by
   // first appending elements. It would be nice to separate the steps into
   // different functions, but D3 seems to handle this poorly and the workarounds
   // can become difficult to follow.
   function appendSparklines(data, domain) {
       // Append the SVG
       var svg = d3.select("#t_trend")
                   .append("svg")
                   .attr("id", "sparklines");

       // Append one container for each row of data
       var sparkline = svg.attr("width", svg_w)
                          .attr("height", svg_h * dataLength + 50)
                          .selectAll("g")
                          .data(data)
                          .enter()
                          .append("g")
                          .attr("class", "sparkline")
                          .attr('id', function(d) { return d.code_name; })
                          .attr("transform", function (d, i) {
                              return "translate(" + margin_t.left + "," + ((margin_t.top + svg_h) * i) + ")";
                          });

       // Append the title text
       sparkline.append("text")
            .text(function(d) { return d.pretty_name})
            .attr("class", "sparkline_title")
            .attr("y", 6)
            .attr("dy", ".71em")
            .style("text-anchor", "start");

      // Append a text element with the initial statistic
       sparkline.append("text")
            .text(function(d) {
              // Return current data with the specified format (f for fixed or p for percentage)
              // The ".2" indicates the level of precision for how numbers are displayed
              // See http://koaning.s3-website-us-west-2.amazonaws.com/html/d3format.html
              return d3.format(".2" + d.value_format)(d.global_min);
            })
            .attr("class", "sparkline_first")
            .attr("transform", "translate(-3,45)")
            .attr("y", 6)
            .attr("dy", ".25em")
            .style("text-anchor", "end");

      // Append a text display of the most current statistic
       sparkline.append("text")
            .text(function(d) {
              // Return current data with the specified format (f for fixed or p for percentage)
              // The ".2" indicates the level of precision for how numbers are displayed
              // See http://koaning.s3-website-us-west-2.amazonaws.com/html/d3format.html
              return d3.format(".2" + d.value_format)(d.current_max);
            })
            .attr("class", "sparkline_current")
            .attr("transform", "translate(" + (sparkline_w - 25) + "," + (sparkline_h / 2) + ")")
            .attr("y", 6)
            .attr("dy", ".25em")
            .style("text-anchor", "start");

       // Append two circles for the current statistic
       // THIS IS WRONG RIGHT NOW
       sparkline.append("circle")
          .attr("cx", sparkline_w - 40)
          .attr("cy", function(d){ return (sparkline_h * d.current_max); })
          .attr("r", 7)
          .attr("class", "trend_end_point")
          .style("fill", "white")
          .attr("transform", "translate(0, 5)");

       sparkline.append("circle")
          .attr("cx", sparkline_w - 40)
          .attr("cy", function(d){ return (sparkline_h * d.current_max); })
          .attr("r", 5)
          .attr("class", "trend_end_point")
          .attr("transform", "translate(0, 5)");

   }

   // Appends a year for every other year from the min and max years passed in from
   // dashboard.js
   function appendSparklineAxis(domain) {
        var xScale = d3.scale.linear()
                       .domain(domain)
                       .range([margin_t.left, sparkline_w - margin_t.right]);

        // First set up the method for creating an axis using d3.svg.axis()
        // and the years array build on initialization
        var xAxis = d3.svg.axis()
            .scale(xScale)
            .orient("bottom")
            .tickFormat(function (d) {
                var strYear = d.toString();
                var formattedYear = "'" + strYear.slice(2);
                return formattedYear;
            })
            .ticks(years.length /2);

        d3.select("#sparklines")
            .append("g")
            .attr("class", "axis")
            .attr("transform", "translate(0," + (svg_h * dataLength + 20) + ")")
            .call(xAxis);
   }

   // Appends one line for each year running the height of the container. This is a little tricky
   // because it is not actually an axis, so the math is different from appendSparklineAxis
   function appendSparklineGrid() {
      // We need a gridline for each year inclusive of the min and
      // max. Build an array of even increments that express how far
      // a line should be from the lft boundary of the container
      var spacedLines = getYearSpacing();

      // Append an element to contain the gridlines
      var grid = d3.select('#sparklines')
                   .append('g')
                   .attr('id', 'grid');

      grid.selectAll('line')
          .data(spacedLines)
          .enter()
          .append('line')
          .attr("x1", function(d) { return d; })
          .attr('y1', 0)
          .attr('x2', function(d) { return d; })
          .attr('y2', svg_h * dataLength + 20)
          .style("stroke", "#aaa")
          .style("stroke-width", .5)
          .style("stroke-opacity", .5)
          .attr("transform", "translate(" + (margin_t.left) + ",0)");

   }

   function bindEvents() {

   }

   // Returns the years between the domain set in dashboard.js
   // This enables us to create the right number of gridlines and
   // axis labels without hand coding the values as was done before.
   //
   // NOTE: The date array is technically two integers. For the purposes
   // of this app and the data that goes into it, integers are fine, but
   // this would need to be rewritten if you want to do more sophisticated
   // date manipulation.
   function getNumYears(domain) {
      // Get the difference between the years so we know how many times
      // to loop. The domain always consists of two integers [min, max],
      // so we can rely on the index numbers
      var diff = domain[1] - domain[0];
      var yearStart = domain[0];
      var years = [];

      for (var i = 0; i <= diff; i++) {
        years.push(yearStart);
        yearStart++;
      }
      return years;
   }

    // Builds an array of even increments that express how far
    // an axis element should be from the left boundary of the 
    // container
   function getYearSpacing() {
      var spacedLines = [];
      var yearObj = {};
      var numYears = years.length;
      for (var i = 0; i < numYears; i++) {
        spacedLines[i] = (320 / numYears) * i;
        yearObj[i] = (320 / numYears) * i;
      }

      return spacedLines;
   }

   function getSparklineData(data) {
        var sparklineData = data.filter(function(row) {
            return row['group'] === 'foster_care_trend';
        });

        return sparklineData;
   }

   return {
      init: init
   }
})();

module.exports = Sparklines;
},{"./Events.js":4}]},{},[1]);
